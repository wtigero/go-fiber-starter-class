package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"sync"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// User represents a user entity
type User struct {
	ID        int32
	Name      string
	Email     string
	CreatedAt string
}

// UserServiceServer implements the gRPC UserService
type UserServiceServer struct {
	mu    sync.RWMutex
	users map[int32]*User
	nextID int32
}

// NewUserServiceServer creates a new server
func NewUserServiceServer() *UserServiceServer {
	s := &UserServiceServer{
		users:  make(map[int32]*User),
		nextID: 1,
	}
	// Add sample data
	s.users[1] = &User{ID: 1, Name: "Alice", Email: "alice@example.com", CreatedAt: time.Now().Format(time.RFC3339)}
	s.users[2] = &User{ID: 2, Name: "Bob", Email: "bob@example.com", CreatedAt: time.Now().Format(time.RFC3339)}
	s.nextID = 3
	return s
}

// GetUser returns a user by ID
func (s *UserServiceServer) GetUser(ctx context.Context, req *GetUserRequest) (*UserProto, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	user, ok := s.users[req.Id]
	if !ok {
		return nil, status.Errorf(codes.NotFound, "user not found: %d", req.Id)
	}

	return &UserProto{
		Id:        user.ID,
		Name:      user.Name,
		Email:     user.Email,
		CreatedAt: user.CreatedAt,
	}, nil
}

// ListUsers returns all users
func (s *UserServiceServer) ListUsers(ctx context.Context, req *ListUsersRequest) (*ListUsersResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var users []*UserProto
	for _, u := range s.users {
		users = append(users, &UserProto{
			Id:        u.ID,
			Name:      u.Name,
			Email:     u.Email,
			CreatedAt: u.CreatedAt,
		})
	}

	return &ListUsersResponse{
		Users: users,
		Total: int32(len(users)),
	}, nil
}

// CreateUser creates a new user
func (s *UserServiceServer) CreateUser(ctx context.Context, req *CreateUserRequest) (*UserProto, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	user := &User{
		ID:        s.nextID,
		Name:      req.Name,
		Email:     req.Email,
		CreatedAt: time.Now().Format(time.RFC3339),
	}
	s.users[user.ID] = user
	s.nextID++

	return &UserProto{
		Id:        user.ID,
		Name:      user.Name,
		Email:     user.Email,
		CreatedAt: user.CreatedAt,
	}, nil
}

// StreamUsers streams users one by one (server streaming)
func (s *UserServiceServer) StreamUsers(req *ListUsersRequest, stream UserService_StreamUsersServer) error {
	s.mu.RLock()
	defer s.mu.RUnlock()

	for _, u := range s.users {
		if err := stream.Send(&UserProto{
			Id:        u.ID,
			Name:      u.Name,
			Email:     u.Email,
			CreatedAt: u.CreatedAt,
		}); err != nil {
			return err
		}
		time.Sleep(100 * time.Millisecond) // Simulate streaming delay
	}

	return nil
}

// Proto message types (normally generated by protoc)
type UserProto struct {
	Id        int32
	Name      string
	Email     string
	CreatedAt string
}

type GetUserRequest struct {
	Id int32
}

type ListUsersRequest struct {
	Page  int32
	Limit int32
}

type ListUsersResponse struct {
	Users []*UserProto
	Total int32
}

type CreateUserRequest struct {
	Name  string
	Email string
}

type UserService_StreamUsersServer interface {
	Send(*UserProto) error
	grpc.ServerStream
}

func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	grpcServer := grpc.NewServer()
	// Note: In real code, you would register the generated service:
	// pb.RegisterUserServiceServer(grpcServer, NewUserServiceServer())

	fmt.Println("ðŸš€ gRPC Server running on :50051")
	fmt.Println("")
	fmt.Println("This is a simplified example.")
	fmt.Println("For full gRPC, run: protoc --go_out=. --go-grpc_out=. proto/user.proto")

	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
